<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://trizzy33.github.io/atom.xml" rel="self"/>
  
  <link href="https://trizzy33.github.io/"/>
  <updated>2021-02-21T16:22:23.722Z</updated>
  <id>https://trizzy33.github.io/</id>
  
  <author>
    <name>trizzy33</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组</title>
    <link href="https://trizzy33.github.io/2021/02/21/post-1/"/>
    <id>https://trizzy33.github.io/2021/02/21/post-1/</id>
    <published>2021-02-21T12:53:52.000Z</published>
    <updated>2021-02-21T16:22:23.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p><a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><h4 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h4><p>时间：O(n)<br>空间：O(1)</p><p>brute force初始版本，写完发现这几个条件其实是重合的，插入到最前面，找到相同的元素，在中间插入，返回的都是当前遍历的i。只要找到了就是当前i位置的元素大于等于target</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> || target &lt; nums.at(<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() &amp;&amp; flag == <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt;= nums.at(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(target == nums.at(i))&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) ans = nums.size();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以写成这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= nums.at(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            midindex = (left + right) / <span class="number">2</span>;</span><br><span class="line">            mid = nums.at(midindex);</span><br><span class="line">            <span class="keyword">if</span>(target &lt; mid) right = midindex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; mid) left = midindex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> midindex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间：O(logn)<br>空间：O(1)</p><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p><a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums.at(i))&#123;</span><br><span class="line">                <span class="keyword">while</span>(nums.at(end) == val &amp;&amp; end &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    nums.at(end) = <span class="number">0</span>;</span><br><span class="line">                    end --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(end &gt;= i) &#123;</span><br><span class="line">                    nums.at(i) = nums.at(end);</span><br><span class="line">                    nums.at(end) = <span class="number">0</span>;</span><br><span class="line">                    end --;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;35-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35. 搜索插入位置&quot;&gt;&lt;/a&gt;35. 搜索插入位置&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://trizzy33.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>101.symmetric binary tree</title>
    <link href="https://trizzy33.github.io/2021/01/14/tree/"/>
    <id>https://trizzy33.github.io/2021/01/14/tree/</id>
    <published>2021-01-14T10:39:46.000Z</published>
    <updated>2021-01-14T11:42:34.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Recursive-Method"><a href="#Recursive-Method" class="headerlink" title="Recursive Method"></a>Recursive Method</h3><p>一开始想比较每个节点的左子树和右子树，然后发现这样比较并不对，仍然返回对称的结果。看了一下解析，是要比较root的两个子树，里外是不是对称的，里面比较left-&gt;right, right-&gt;left, 相对的外边就是right-&gt;right, left-&gt;left。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//recursive method</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;right, root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* right, TreeNode* left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span> &amp;&amp; left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right != <span class="literal">NULL</span> &amp;&amp; left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="literal">NULL</span> &amp;&amp; left != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right-&gt;val != left-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> outside = helper(right-&gt;right, left-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> inside = helper(right-&gt;left, left-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> sym = outside &amp;&amp; inside;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sym;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Iterative-Method"><a href="#Iterative-Method" class="headerlink" title="Iterative Method"></a>Iterative Method</h3><p>用queue每次推入里侧外侧的四个节点，不为空的时候一直循环，跟递归不同的是检测到都为NULL的时候不做任何操作，因为只返回一次，要是写了return true结果就直接为true了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//iterative method</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qe;</span><br><span class="line">        qe.push(root-&gt;left);</span><br><span class="line">        qe.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!qe.empty())&#123;</span><br><span class="line">            TreeNode* left = qe.front();</span><br><span class="line">            qe.pop();</span><br><span class="line">            TreeNode* right = qe.front();</span><br><span class="line">            qe.pop();</span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) || (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="literal">NULL</span> &amp;&amp; left == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span> &amp;&amp; right-&gt;val == left-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//compare outside</span></span><br><span class="line">                qe.push(left-&gt;left);</span><br><span class="line">                qe.push(right-&gt;right);</span><br><span class="line">                <span class="comment">//compare inside</span></span><br><span class="line">                qe.push(left-&gt;right);</span><br><span class="line">                qe.push(right-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Recursive-Method&quot;&gt;&lt;a href=&quot;#Recursive-Method&quot; class=&quot;headerlink&quot; title=&quot;Recursive Method&quot;&gt;&lt;/a&gt;Recursive Method&lt;/h3&gt;&lt;p&gt;一开始想比较每个节点的左子树</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://trizzy33.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>记录</title>
    <link href="https://trizzy33.github.io/2021/01/13/post/"/>
    <id>https://trizzy33.github.io/2021/01/13/post/</id>
    <published>2021-01-13T09:44:10.000Z</published>
    <updated>2021-01-13T11:16:07.467Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上从被窝爬起来刷牙洗脸，水冰的我想回去倒头再睡几个小时。学跳舞已经变得有点烦了，主要还是我学的太烂了。今天终于少了一个穿短裙跳舞的阿姨，之前做动作我看她的打底裤就还挺尴尬的，虽然跟我没有什么关系，但是我确实还是会多事的觉得别人穿的衣服有点跟场合不太符合。摸了一天鱼看了十分钟的教材，其实早上起来的时候情绪有点崩溃，我好像不能太晚睡觉，每天都在做噩梦，感觉很难受，脑子就没有停下来的一刻。闲着没事干找到了遗体捐献的公众号，登记了一下身份证号跟名字，这个居然也不要求什么本人验证，好歹加一个人脸验证，虽然警告写了不能冒名登记…嗯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天早上从被窝爬起来刷牙洗脸，水冰的我想回去倒头再睡几个小时。学跳舞已经变得有点烦了，主要还是我学的太烂了。今天终于少了一个穿短裙跳舞的阿姨，之前做动作我看她的打底裤就还挺尴尬的，虽然跟我没有什么关系，但是我确实还是会多事的觉得别人穿的衣服有点跟场合不太符合。摸了一天鱼看了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记</title>
    <link href="https://trizzy33.github.io/2021/01/07/note/"/>
    <id>https://trizzy33.github.io/2021/01/07/note/</id>
    <published>2021-01-07T10:32:12.000Z</published>
    <updated>2021-01-14T11:42:25.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>连续，fix sized</li><li>存储的都是相同type的数据<br>内存部分是连续的，lowest address是第一个数据，highest address则是最后一个数据.每次在插入和删除的时候都需要整段整段的改变。</li><li>Complexity</li></ul><table><thead><tr><th>Access</th><th>Search</th><th>Insertion</th><th>Deletion</th></tr></thead><tbody><tr><td>Θ(1)</td><td>Θ(n)</td><td>Θ(n)</td><td>Θ(n)</td></tr></tbody></table><blockquote><p>declare <code>type arrayName [ arraySize ];</code></p></blockquote><blockquote><p>example <code>char a1[5];</code></p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h2 id="Unordered-Map"><a href="#Unordered-Map" class="headerlink" title="Unordered Map"></a>Unordered Map</h2><p>和Map不同，实现结构是hash map，普通的map则是红黑树</p><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><blockquote><p>init<br>   <code>unordered_map&lt;int, int&gt; mp;</code></p></blockquote><blockquote><p>count <code>map.count(key)</code> 返回0或者1，因为key是unique的</p></blockquote><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连续，fix sized&lt;/li&gt;
&lt;li&gt;存储的都是相同type的数据&lt;br&gt;内存部分是连续的，lowest address是</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://trizzy33.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
